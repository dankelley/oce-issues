---
title: Can we speed up interpBarnes()?
author: Dan Kelley
---

How to work here

1. Remove oce and reinstall from CRAN.
2. Edit 1880a.R, setting build<-TRUE in the first line.
3. Uninstall the local oce, and install the CRAN version instead.
3. Type 'make' to create the 1880a_cran.rda file. (Note of the execution time.)
4. Add this rda file to the repo.
5. Edit 1880a.R again, changing the first line to build<-FALSE
6. Rebuild a local copy of oce.
7. Run 'make' again.  This should run without errors, unless the local oce is
   creating different results from the CRAN oce.


# Performance/coding notes

## Should we use C++ array-based methods more?

Instead of looping in the C manner,
```
for (int i = 0; i < nxg; i++)
   for (int j = 0; j < nyg; j++)
     zg(i, j) = zz(i, j);
```
we can use
```
zg = clone(zz);
```
which should be clearer to readers.  I ran multiple timing tests as
I experimented, monitoring the t.test output until the 95%CI was under 0.1s.  

* using C   style assignments: 5.358 ± 0.097 s
* using C++ style assignments: 3.993 ± 0.051 s

So, the C++ style seems to be 25% faster (perhaps because it avoids the
overhead of overloading the `[` and `)` operators) and also more elegant.
I will switch the code.

## Use RCpp zz(i,j) or C-style pointer based access?

Use RCpp style.

Test 3 (C pointer style)
```R
        *(zzp+i+j*nxg) = interpolate_barnes(xg[i], yg[j], *(zzp+i+j*nxg),
```
took 5.550 ± 0.033 s.


Test 4 (RCpp style)
```R
        zz(i, j) = interpolate_barnes(xg[i], yg[j], zz(i, j),
```
took 5.559 ± 0.034 s.

These results are identical, so there is no speed advantage to using
C pointers, and the code is much clearer in the RCpp style.

## Use index method on z_last() and z_g(i,j), or clone method?

Test 5 is like test 4, but using loops to assign.  It gave 5.538±0.034 s, which
is the same as Test 4 (just) within error bars, so the choice comes down to
code clarity, e.g. is
```
  zg = clone(zz);
```
clearer than
```
  for (int i = 0; i < nxg; i++)
    for (int j = 0; j < nyg; j++)
      zg(i, j) = zz(i, j);
```

I think the index method is clearer (and it sidesteps the confusing need to
clone), so I will stick with that, which is how this has been done for years.

*Conclusion.* Use index method.

## Use an alternate exp() calculator?

The code in `src/interp_barnes.cpp` has an old approximate-exp method, so
I turned that on, in Test 6, which took 2.453 ± 0.008 s, a bit more than 2X the
speed of Test 5, which took 5.538 ± 0.034 s.

This method 'costs' 5 multiplies and has under 0.1% error.  However, I think I
can achieve 0.01% error at similar speed, using another method (next
section). I suppose we should let users retain their old results, but I can add
a new arg to `interpBarnes()` called `fast` to optionally use the fast method.

**Conclusion.** We may be able to improve speeds noticeably by using an
alternative exp().

# Idea
```{r}
# For the Barnes algorithm, we have exp(-distance^2), which is always exp(x)
# where x <= 0.
#
# Idea: write e.g.  exp(-5.1) as exp(-6) * exp(0.9),
# and use lookup table for the first part, for maybe -50 to 0 or
# whatever, and then make a lookup table or Taylor series (as below)
# for the fraction part.

# Integer part
xi <- seq(0, 50, 1)
ei <- exp(-xi)

# Taylor series
taylor <- function(x)
{
    1 + x * (1 + x * (1/2 + x * (1/6 + x * (1/24 + x*(1/120 + x/720)))))
}

# Combine
EXP <- function(x)
{
    i <- as.integer(floor(x))
    f <- x - i
    I <- ei[1-i]
    F <- taylor(f)
    #message("i=", i, " I=",I, " f=", f, " F=", F)
    I * F
}

# Test
x <- seq(-20, 0, length.out=1000)
E <- unlist(lapply(x, EXP))
plot(x, 100*(1-E/exp(x)), type="o", pch=20, cex=0.5, ylab="Percent error")

```

